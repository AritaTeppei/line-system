// src/customers/customers.service.ts
import {
  BadRequestException,
  ForbiddenException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import type { AuthPayload } from '../auth/auth.service';
import { Prisma } from '@prisma/client';

@Injectable()
export class CustomersService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * テナントIDを取り出すヘルパー
   * - DEVELOPER はここでは禁止（顧客操作はテナントで行う想定）
   * - MANAGER / CLIENT は tenantId 必須
   */
  private ensureTenant(user: AuthPayload): number {
    if (user.role === 'DEVELOPER') {
      throw new ForbiddenException(
        '顧客の操作はテナントユーザーで行ってください',
      );
    }
    if (!user.tenantId) {
      throw new ForbiddenException('テナントが特定できません');
    }
    return user.tenantId;
  }

  /**
   * ログインユーザーに紐づく顧客一覧
   */
    async findAllForUser(user: AuthPayload) {
    const tenantId = this.ensureTenant(user);

    // 顧客と一緒に「cars の件数」も取る
    const rows = await this.prisma.customer.findMany({
      where: { tenantId },
      orderBy: { id: 'asc' }, // ここは今使ってる orderBy に合わせてOK
      include: {
        _count: {
          select: { cars: true },
        },
      },
    });

    // フロントで扱いやすいように hasVehicle を付けて返す
    return rows.map((c) => ({
      id: c.id,
      tenantId: c.tenantId,
      lastName: c.lastName,
      firstName: c.firstName,
      postalCode: c.postalCode,
      address1: c.address1,
      address2: c.address2,
      mobilePhone: c.mobilePhone,
      lineUid: c.lineUid,
      birthday: c.birthday,
      // ★ ここがタグの元ネタ
      hasVehicle: c._count.cars > 0,
    }));
  }


  /**
   * 顧客新規作成
   * - tenantId はログインユーザーから決定
   * - mobilePhone / lineUid の一意制約違反時は分かりやすいメッセージに変換
   * - birthday は "YYYY-MM-DD" 文字列で受け取り Date に変換
   */
  async createForUser(
    user: AuthPayload,
    data: {
      lastName: string;
      firstName: string;
      postalCode?: string;
      address1?: string;
      address2?: string;
      mobilePhone?: string;
      lineUid?: string;
      birthday?: string;
    },
  ) {
    const tenantId = this.ensureTenant(user);

    try {
      return await this.prisma.customer.create({
        data: {
          tenantId,
          lastName: data.lastName,
          firstName: data.firstName,
          postalCode: data.postalCode,
          address1: data.address1,
          address2: data.address2,
          mobilePhone: data.mobilePhone,
          lineUid: data.lineUid,
          birthday: data.birthday ? new Date(data.birthday) : undefined,
        },
      });
    } catch (e) {
      if (
        e instanceof Prisma.PrismaClientKnownRequestError &&
        e.code === 'P2002'
      ) {
        // 一意制約違反
        const rawTarget = e.meta?.target as string[] | string | undefined;
        const targets =
          typeof rawTarget === 'string' ? [rawTarget] : rawTarget ?? [];

        if (targets.some((t) => t.includes('mobilePhone'))) {
          throw new BadRequestException(
            'この携帯番号は既に登録されています',
          );
        }

        if (targets.some((t) => t.includes('lineUid'))) {
          throw new BadRequestException(
            'このLINE UIDは既に登録されています',
          );
        }

        throw new BadRequestException('顧客情報の一意制約エラーが発生しました');
      }

      throw e;
    }
  }

  /**
   * 単一顧客の取得（テナントチェック付き）
   */
  async findOneForUser(user: AuthPayload, id: number) {
    const tenantId = this.ensureTenant(user);

    const customer = await this.prisma.customer.findFirst({
      where: { id, tenantId },
    });

    if (!customer) {
      throw new NotFoundException('顧客が見つかりません');
    }

    return customer;
  }

  /**
   * 顧客更新
   * - テナントチェック
   * - 一意制約違反も create と同様にハンドリング
   * - birthday があれば Date に変換して保存
   */
  async updateForUser(
    user: AuthPayload,
    id: number,
    data: {
      lastName?: string;
      firstName?: string;
      postalCode?: string;
      address1?: string;
      address2?: string;
      mobilePhone?: string;
      lineUid?: string;
      birthday?: string;
    },
  ) {
    const tenantId = this.ensureTenant(user);

    const existing = await this.prisma.customer.findFirst({
      where: { id, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('顧客が見つかりません');
    }

    // birthday だけ Date に変換した updateData を組み立てる
    const updateData: any = { ...data };
    if (data.birthday !== undefined) {
      updateData.birthday = data.birthday ? new Date(data.birthday) : null;
    }

    try {
      return await this.prisma.customer.update({
        where: { id },
        data: updateData,
      });
    } catch (e) {
      if (
        e instanceof Prisma.PrismaClientKnownRequestError &&
        e.code === 'P2002'
      ) {
        const rawTarget = e.meta?.target as string[] | string | undefined;
        const targets =
          typeof rawTarget === 'string' ? [rawTarget] : rawTarget ?? [];

        if (targets.some((t) => t.includes('mobilePhone'))) {
          throw new BadRequestException(
            'この携帯番号は既に登録されています',
          );
        }

        if (targets.some((t) => t.includes('lineUid'))) {
          throw new BadRequestException(
            'このLINE UIDは既に登録されています',
          );
        }

        throw new BadRequestException('顧客情報の一意制約エラーが発生しました');
      }

      throw e;
    }
  }

    /**
   * LINE からの登録／更新用
   * - tenantId + mobilePhone で既存顧客を探す
   * - 見つかればその顧客に lineUid を紐づけて情報を上書き／補完
   * - 見つからなければ新規顧客として作成
   *
   * ※ AuthPayload は使わず、LINE 側などから直接 tenantId をもらって使う想定
   */


  /**
   * LINE からの登録／更新用
   * - tenantId + mobilePhone で既存顧客を探す
   * - 見つかればその顧客に lineUid を紐づけて情報を上書き／補完
   * - 見つからなければ新規顧客として作成
   *
   * ※ 既存の create/update API は一切触らない
   */
  async upsertFromLineByMobilePhone(
    tenantId: number,
    data: {
      mobilePhone: string;
      lineUid: string;
      lastName?: string;
      firstName?: string;
      postalCode?: string;
      address1?: string;
      address2?: string;
      birthday?: string; // "2025-12-02" みたいな文字列想定
    },
  ) {
    try {
      // 1. 既存顧客を検索（このテナント内で、電話番号が一致するもの）
      const existing = await this.prisma.customer.findFirst({
        where: {
          tenantId,
          mobilePhone: data.mobilePhone,
        },
      });

      if (existing) {
        // 2-A. 既存顧客がいる場合 → その顧客を更新
        //     - lineUid は常に上書き
        //     - 他の項目は「undefined のときはそのまま」「指定があれば上書き」
        const updateData: any = {
          lineUid: data.lineUid,
        };

        if (data.lastName !== undefined) {
          updateData.lastName = data.lastName;
        }
        if (data.firstName !== undefined) {
          updateData.firstName = data.firstName;
        }
        if (data.postalCode !== undefined) {
          updateData.postalCode = data.postalCode;
        }
        if (data.address1 !== undefined) {
          updateData.address1 = data.address1;
        }
        if (data.address2 !== undefined) {
          updateData.address2 = data.address2;
        }
        if (data.birthday !== undefined) {
          updateData.birthday = data.birthday
            ? new Date(data.birthday)
            : null;
        }

        return await this.prisma.customer.update({
          where: { id: existing.id },
          data: updateData,
        });
      }

      // 2-B. 見つからなければ新規作成
      return await this.prisma.customer.create({
        data: {
          tenantId,
          lastName: data.lastName ?? '',
          firstName: data.firstName ?? '',
          postalCode: data.postalCode,
          address1: data.address1,
          address2: data.address2,
          mobilePhone: data.mobilePhone,
          lineUid: data.lineUid,
          birthday: data.birthday ? new Date(data.birthday) : undefined,
        },
      });
    } catch (e) {
      // create/update と同じノリの一意制約エラーハンドリング
      if (
        e instanceof Prisma.PrismaClientKnownRequestError &&
        e.code === 'P2002'
      ) {
        const rawTarget = e.meta?.target as string[] | string | undefined;
        const targets =
          typeof rawTarget === 'string' ? [rawTarget] : rawTarget ?? [];

        if (targets.some((t) => t.includes('mobilePhone'))) {
          throw new BadRequestException(
            'この携帯番号は既に登録されています',
          );
        }

        if (targets.some((t) => t.includes('lineUid'))) {
          throw new BadRequestException(
            'このLINE UIDは既に登録されています',
          );
        }

        throw new BadRequestException('顧客情報の一意制約エラーが発生しました');
      }

      throw e;
    }
  }

  /**
   * 顧客削除
   * - 自テナントの顧客かチェック
   * - 車両・予約がある場合は削除不可
   * - ログ系（メッセージログ・リマインドログ・一括送信ログ）は自動的に削除してから顧客を削除
   */
  async removeForUser(user: AuthPayload, id: number) {
    const tenantId = this.ensureTenant(user);

    // 1. 自テナントの顧客か確認
    const existing = await this.prisma.customer.findFirst({
      where: { id, tenantId },
    });

    if (!existing) {
      throw new NotFoundException('顧客が見つかりません');
    }

    // 2. 関連データの有無をチェック
    const [
      carsCount,
      bookingsCount,
      messageLogsCount,
      reminderLogsCount,
      broadcastLogCustomersCount,
    ] = await this.prisma.$transaction([
      // 車両
      this.prisma.car.count({
        where: { tenantId, customerId: id },
      }),
      // 予約
      this.prisma.booking.count({
        where: { tenantId, customerId: id },
      }),
      // メッセージログ
      this.prisma.messageLog.count({
        where: { tenantId, customerId: id },
      }),
      // リマインド送信ログ
      this.prisma.reminderSentLog.count({
        where: { tenantId, customerId: id },
      }),
      // 一括送信ログ（中間テーブル）
      this.prisma.broadcastLogCustomer.count({
        where: {
          customerId: id,
          broadcastLog: {
            tenantId,
          },
        },
      }),
    ]);

    // 3. 車両 or 予約がある場合は削除禁止
    if (carsCount > 0 || bookingsCount > 0) {
      throw new BadRequestException(
        'この顧客には車両または予約が紐づいているため削除できません。先に車両や予約を削除してください。',
      );
    }

    // 4. ログ系は自動で削除してから顧客を削除
    try {
      await this.prisma.$transaction([
        // 一括送信ログとの紐づけ
        this.prisma.broadcastLogCustomer.deleteMany({
          where: {
            customerId: id,
            broadcastLog: {
              tenantId,
            },
          },
        }),
        // メッセージログ
        this.prisma.messageLog.deleteMany({
          where: { tenantId, customerId: id },
        }),
        // リマインド送信ログ
        this.prisma.reminderSentLog.deleteMany({
          where: { tenantId, customerId: id },
        }),
        // 顧客本体
        this.prisma.customer.delete({
          where: { id },
        }),
      ]);

      return { success: true };
    } catch (e) {
      // 念のため外部キー制約はここでも拾っておく
      if (
        e instanceof Prisma.PrismaClientKnownRequestError &&
        e.code === 'P2003'
      ) {
        throw new BadRequestException(
          '関連データが残っているため顧客を削除できません。',
        );
      }
      throw e;
    }
  }
}
