// backend/src/admin/admin-tenants.controller.ts
import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  ParseIntPipe,
  BadRequestException,
  NotFoundException,
  UseGuards,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Prisma, UserRole } from '@prisma/client';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { RolesGuard } from '../auth/roles.guard';
import { Roles } from '../auth/roles.decorator';

// ★ 追加：許可するプラン
const ALLOWED_PLANS = ['BASIC', 'STANDARD', 'PRO'] as const;
type PlanType = (typeof ALLOWED_PLANS)[number];

// 新規作成用 DTO（email / plan は Prisma 側に合わせて必須）
type CreateTenantDto = {
  name: string;
  email: string;
  plan: string; // フロントからは文字列で飛んでくる想定
  isActive?: boolean;
  validUntil?: string | null; // "2025-12-31" などの文字列

  // ★ 契約者情報（任意）
  companyName?: string | null;
  companyAddress1?: string | null;
  companyAddress2?: string | null;
  representativeName?: string | null;
  contactPhone?: string | null;
  contactMobile?: string | null;
};

// 更新用 DTO（全部任意。来たものだけ反映）
type UpdateTenantDto = {
  name?: string;
  email?: string;
  plan?: string;
  isActive?: boolean;
  validUntil?: string | null;

  // ★ こっちにも同じプロパティを定義する
  companyName?: string | null;
  companyAddress1?: string | null;
  companyAddress2?: string | null;
  representativeName?: string | null;
  contactPhone?: string | null;
  contactMobile?: string | null;
};

@Controller('admin/tenants')
export class AdminTenantsController {
  constructor(private readonly prisma: PrismaService) {}

  // 既存：一覧（overview）
  @Get('overview')
  async getOverview() {
    const tenants = await this.prisma.tenant.findMany({
      orderBy: { id: 'asc' },
      include: {
        _count: {
          select: {
            customers: true,
            cars: true,
            bookings: true,
          },
        },
      },
    });

    return tenants.map((t: any) => ({
      id: t.id,
      name: t.name,
      email: t.email ?? null,
      plan: t.plan ?? null,
      isActive: t.isActive ?? true,
      validUntil: t.validUntil ?? null,
      customersCount: t._count?.customers ?? 0,
      carsCount: t._count?.cars ?? 0,
      bookingsCount: t._count?.bookings ?? 0,

      // ★ 契約者情報（一覧で使うかどうかはフロント次第）
      companyName: t.companyName ?? null,
      companyAddress1: t.companyAddress1 ?? null,
      companyAddress2: t.companyAddress2 ?? null,
      representativeName: t.representativeName ?? null,
      contactPhone: t.contactPhone ?? null,
      contactMobile: t.contactMobile ?? null,
    }));
  }

  // ★ 編集用：単一テナント取得
  @Get(':id')
  async getTenant(@Param('id') id: string) {
    const tenantId = Number(id);
    if (Number.isNaN(tenantId)) {
      throw new BadRequestException('ID が不正です');
    }

    const t = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      include: {
        _count: {
          select: {
            customers: true,
            cars: true,
            bookings: true,
          },
        },
      },
    });

    if (!t) {
      throw new NotFoundException('テナントが見つかりません');
    }

    // overview と同じ形で1件だけ返す
    return {
      id: t.id,
      name: t.name,
      email: t.email ?? null,
      plan: t.plan ?? null,
      isActive: t.isActive ?? true,
      validUntil: t.validUntil ?? null,
      customersCount: t._count?.customers ?? 0,
      carsCount: t._count?.cars ?? 0,
      bookingsCount: t._count?.bookings ?? 0,

      // ★ 契約者情報
      companyName: t.companyName ?? null,
      companyAddress1: t.companyAddress1 ?? null,
      companyAddress2: t.companyAddress2 ?? null,
      representativeName: t.representativeName ?? null,
      contactPhone: t.contactPhone ?? null,
      contactMobile: t.contactMobile ?? null,
    };
  }

  // 既存：新規作成
  @Post()
  async createTenant(@Body() body: CreateTenantDto) {
    if (!body.name?.trim()) {
      throw new BadRequestException('テナント名は必須です');
    }
    if (!body.email?.trim()) {
      throw new BadRequestException('メールアドレスは必須です');
    }
    if (!body.plan?.trim()) {
      throw new BadRequestException('プランは必須です');
    }

    // ★ ここで plan を正規化＆チェック（BASIC / STANDARD / PRO）
    const plan = body.plan.trim().toUpperCase();
    if (!ALLOWED_PLANS.includes(plan as PlanType)) {
      throw new BadRequestException(
        'プランは BASIC / STANDARD / PRO のいずれかを指定してください',
      );
    }

    const validUntil =
      body.validUntil && body.validUntil.trim()
        ? new Date(body.validUntil)
        : null;

    if (validUntil && Number.isNaN(validUntil.getTime())) {
      throw new BadRequestException('validUntil の日付形式が不正です');
    }

    const data: Prisma.TenantCreateInput = {
      name: body.name.trim(),
      email: body.email.trim(),
      plan, // ← 正規化済みの plan を保存
      isActive: body.isActive ?? true,
      validUntil,

      // ★ 契約者情報（空文字は null に寄せる）
      companyName: body.companyName?.trim() || null,
      companyAddress1: body.companyAddress1?.trim() || null,
      companyAddress2: body.companyAddress2?.trim() || null,
      representativeName: body.representativeName?.trim() || null,
      contactPhone: body.contactPhone?.trim() || null,
      contactMobile: body.contactMobile?.trim() || null,
    };

    const tenant = await this.prisma.tenant.create({ data });

    return {
      id: tenant.id,
      name: tenant.name,
      email: tenant.email ?? null,
      plan: tenant.plan ?? null,
      isActive: tenant.isActive ?? true,
      validUntil: tenant.validUntil ?? null,
      customersCount: 0,
      carsCount: 0,
      bookingsCount: 0,

      companyName: tenant.companyName ?? null,
      companyAddress1: tenant.companyAddress1 ?? null,
      companyAddress2: tenant.companyAddress2 ?? null,
      representativeName: tenant.representativeName ?? null,
      contactPhone: tenant.contactPhone ?? null,
      contactMobile: tenant.contactMobile ?? null,
    };
  }

  // ★追加：既存テナントの編集
  @Patch(':id')
  async updateTenant(@Param('id') id: string, @Body() body: UpdateTenantDto) {
    const tenantId = Number(id);
    if (Number.isNaN(tenantId)) {
      throw new BadRequestException('ID が不正です');
    }

    const data: Prisma.TenantUpdateInput = {};

    if (body.name && body.name.trim()) {
      data.name = body.name.trim();
    }

    if (body.email && body.email.trim()) {
      data.email = body.email.trim();
    }

    if (body.plan && body.plan.trim()) {
      const plan = body.plan.trim().toUpperCase();
      if (!ALLOWED_PLANS.includes(plan as PlanType)) {
        throw new BadRequestException(
          'プランは BASIC / STANDARD / PRO のいずれかを指定してください',
        );
      }
      data.plan = plan;
    }

    if (typeof body.isActive === 'boolean') {
      data.isActive = body.isActive;
    }

    // validUntil が undefined でなければ、「更新対象」として扱う
    if (body.validUntil !== undefined) {
      if (!body.validUntil) {
        // 空文字 or null → null にクリア
        data.validUntil = null;
      } else {
        const v = new Date(body.validUntil);
        if (Number.isNaN(v.getTime())) {
          throw new BadRequestException('validUntil の日付形式が不正です');
        }
        data.validUntil = v;
      }
    }

    // ★ 契約者情報の更新（undefined の場合は触らない／null or "" でクリア）
    if (body.companyName !== undefined) {
      data.companyName = body.companyName?.trim() || null;
    }
    if (body.companyAddress1 !== undefined) {
      data.companyAddress1 = body.companyAddress1?.trim() || null;
    }
    if (body.companyAddress2 !== undefined) {
      data.companyAddress2 = body.companyAddress2?.trim() || null;
    }
    if (body.representativeName !== undefined) {
      data.representativeName = body.representativeName?.trim() || null;
    }
    if (body.contactPhone !== undefined) {
      data.contactPhone = body.contactPhone?.trim() || null;
    }
    if (body.contactMobile !== undefined) {
      data.contactMobile = body.contactMobile?.trim() || null;
    }

    const tenant = await this.prisma.tenant.update({
      where: { id: tenantId },
      data,
    });

    // ★ ここから追記：プランに応じて MANAGER の maxConcurrentSessions を更新
    let maxSessionsForManager: number | null = null;

    // tenant.plan は String 型（"BASIC" / "STANDARD" / "PRO"）想定
    switch (tenant.plan) {
      case 'STANDARD':
        maxSessionsForManager = 2;
        break;
      case 'PRO':
        maxSessionsForManager = 3;
        break;
      case 'BASIC':
      default:
        maxSessionsForManager = 1;
        break;
    }

    // MANAGER ユーザーだけまとめて更新
    if (maxSessionsForManager !== null) {
      await this.prisma.user.updateMany({
        where: {
          tenantId: tenantId,
          role: UserRole.MANAGER,
        },
        data: {
          maxConcurrentSessions: maxSessionsForManager,
        },
      });
    }
    // ★ 追記ここまで

    return {
      id: tenant.id,
      name: tenant.name,
      email: tenant.email ?? null,
      plan: tenant.plan ?? null,
      isActive: tenant.isActive ?? true,
      validUntil: tenant.validUntil ?? null,
      // カウントはここでは取っていないので 0 固定
      customersCount: 0,
      carsCount: 0,
      bookingsCount: 0,

      companyName: tenant.companyName ?? null,
      companyAddress1: tenant.companyAddress1 ?? null,
      companyAddress2: tenant.companyAddress2 ?? null,
      representativeName: tenant.representativeName ?? null,
      contactPhone: tenant.contactPhone ?? null,
      contactMobile: tenant.contactMobile ?? null,
    };
  }

  // ★追加：既存テナントの削除
  @Delete(':id')
  async deleteTenant(@Param('id') id: string) {
    const tenantId = Number(id);
    if (Number.isNaN(tenantId)) {
      throw new BadRequestException('ID が不正です');
    }

    // ★ ここをトランザクションに変更
    const tenant = await this.prisma.$transaction(async (tx) => {
      // ① 先に LineSettings を削除（無ければ0件で何も起きない）
      await tx.lineSettings.deleteMany({
        where: { tenantId },
      });

      // 必要なら他のテーブルもここに足していける
      // await tx.reminderSentLog.deleteMany({ where: { tenantId } });
      // await tx.booking.deleteMany({ where: { tenantId } });
      // ...など

      // ② 最後にテナント本体を削除
      return tx.tenant.delete({
        where: { id: tenantId },
      });
    });

    // 削除したテナント情報を返すのはそのまま
    return {
      id: tenant.id,
      name: tenant.name,
      email: tenant.email ?? null,
      plan: tenant.plan ?? null,
    };
  }


  // ▼ ここのメソッド群は元のまま（挙動変えたくないのでそのまま残してる）

  @Patch('')
  @Delete(':userId')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('DEVELOPER')
  async deleteTenantUser(
    @Param('tenantId') tenantId: number,
    @Param('userId') userId: number,
  ) {
    const user = await this.prisma.user.findUnique({ where: { id: userId } });
    if (!user) {
      throw new NotFoundException('ユーザーが見つかりません');
    }
    if (user.role === 'DEVELOPER') {
      throw new ForbiddenException('DEVELOPER は削除できません');
    }
    if (user.tenantId !== tenantId) {
      throw new ForbiddenException('このテナントのユーザーではありません');
    }

    await this.prisma.user.delete({
      where: { id: userId },
    });

    return { success: true };
  }

  @Post(':tenantId/reset-data')
  async resetTenantData(@Param('tenantId', ParseIntPipe) tenantId: number) {
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
    });

    if (!tenant) {
      throw new NotFoundException('テナントが存在しません');
    }

    await this.prisma.$transaction(async (tx) => {
      await tx.reminderSentLog.deleteMany({
        where: { tenantId },
      });

      await tx.booking.deleteMany({
        where: { tenantId },
      });

      await tx.car.deleteMany({
        where: { tenantId },
      });

      await tx.customer.deleteMany({
        where: { tenantId },
      });
    });

    return {
      success: true,
      tenantId,
      message: '指定テナントのデータをリセットしました',
    };
  }
}
