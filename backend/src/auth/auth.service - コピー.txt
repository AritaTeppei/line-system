// src/auth/auth.service.ts
import { Injectable, UnauthorizedException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import * as jwt from 'jsonwebtoken';
import type { Request } from 'express';
import { UserRole } from '@prisma/client';
import * as bcrypt from 'bcrypt';

// JWT に入れる型
export interface AuthPayload {
  id: number;
  email: string;
  name: string | null;
  tenantId: number | null;  // 開発者は null
  role: UserRole;           // 'DEVELOPER' | 'MANAGER' | 'CLIENT'
}

@Injectable()
export class AuthService {
  // 本番では必ず環境変数に逃がすこと！
  private readonly JWT_SECRET =
    process.env.JWT_SECRET ?? 'development-only-secret';

  constructor(private readonly prisma: PrismaService) {}

    // ★ 追加：プラン＆ロールから同時ログイン上限を返す
  private getMaxSessionsForUser(
    role: UserRole,
    tenantPlan: string | null,
  ): number {
    // 開発者は制限なし（実質無制限扱いの大きい数字）
    if (role === UserRole.DEVELOPER) {
      return 9999;
    }

    // CLIENT はプランに関係なく常に 1
    if (role === UserRole.CLIENT) {
      return 1;
    }

    // MANAGER はテナントの plan で分岐（文字列 BASIC / STANDARD / PRO を想定）
    const plan = (tenantPlan ?? 'BASIC').toUpperCase();

    switch (plan) {
      case 'STANDARD':
        return 2;
      case 'PRO':
        return 3;
      case 'BASIC':
      default:
        return 1;
    }
  }
  /**
   * メールアドレスとパスワードからユーザーを1件取得して検証
   */
  async validateUser(email: string, password: string) {
    const user = await this.prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      throw new UnauthorizedException('メールアドレスまたはパスワードが違います');
    }

    // 既存（平文）と新規（ハッシュ済み）の両方に対応したパスワードチェック
    const { ok, hashed } = await this.verifyPassword(password, user.password);

    if (!ok) {
      throw new UnauthorizedException('メールアドレスまたはパスワードが違います');
    }

    // 旧データ（平文保存）の場合は、このタイミングでハッシュ化に移行する
    if (!hashed) {
      const newHash = await bcrypt.hash(password, 10);
      await this.prisma.user.update({
        where: { id: user.id },
        data: { password: newHash },
      });
    }

    return user;
  }

    /**
   * ログイン用:
   * - メール＋パスワードでユーザーを検証
   * - AuthPayload を組み立て
   * - MANAGER / CLIENT の場合はテナントの有効状態もチェック
   * - 問題なければ { user, payload } を返す
   */
  async validateUserWithTenantCheck(email: string, password: string): Promise<{
    user: any;
    payload: AuthPayload;
  }> {
    // まずは通常のユーザー検証
    const user = await this.validateUser(email, password);

    // AuthPayload を組み立て
    const payload: AuthPayload = {
      id: user.id,
      email: user.email,
      name: (user as any).name ?? null,
      tenantId: user.tenantId ?? null,
      role: user.role,
    };

    // テナント状態チェック（DEVELOPER は ensureTenantActive の中でスルーされる）
    await this.ensureTenantActive(payload);

        // ★ 追加：同時ログイン数のチェック
    await this.ensureSessionLimit(payload);

    // ★ 追加：問題なければセッションを1行作成
    await this.createSession(payload);

    return { user, payload };
  }

  /**
   * JWT を発行する
   */
  issueToken(payload: AuthPayload): string {
    const token = jwt.sign(payload, this.JWT_SECRET, {
      expiresIn: '7d', // とりあえず7日有効
    });
    return token;
  }

  /**
   * JWT を検証して payload を取り出す
   */
  verifyToken(token: string): AuthPayload | null {
    try {
      const decoded = jwt.verify(token, this.JWT_SECRET);
      return decoded as AuthPayload;
    } catch (e) {
      return null;
    }
  }

  /**
   * Request から Authorization ヘッダーを読み取る
   */
  getPayloadFromRequest(req: Request): AuthPayload | null {
    const header = req.headers['authorization'];
    if (!header || typeof header !== 'string') return null;

    const [scheme, token] = header.split(' ');
    if (scheme !== 'Bearer' || !token) return null;

    return this.verifyToken(token);
  }

  /**
   * 既存（平文）パスワードと、新しいハッシュ済みパスワードの両方に対応した比較
   */
  private async verifyPassword(
    plainPassword: string,
    storedPassword: string,
  ): Promise<{ ok: boolean; hashed: boolean }> {
    if (!storedPassword) {
      return { ok: false, hashed: false };
    }

    // bcrypt っぽい文字列ならハッシュとみなす
    const looksHashed =
      storedPassword.startsWith('$2b$') ||
      storedPassword.startsWith('$2a$') ||
      storedPassword.startsWith('$2y$');

    if (looksHashed) {
      const ok = await bcrypt.compare(plainPassword, storedPassword);
      return { ok, hashed: true };
    }

    // それ以外は「昔の平文保存」とみなして、そのまま比較
    const ok = plainPassword === storedPassword;
    return { ok, hashed: false };
  }

    /**
   * /auth/me 用：
   * - JWT を検証して payload を取り出す
   * - MANAGER / CLIENT の場合はテナントの有効状態もチェックする
   * - DEVELOPER はテナント状態に関係なく通す
   */
  async getPayloadFromRequestWithTenantCheck(req: Request): Promise<AuthPayload> {
    const payload = this.getPayloadFromRequest(req);

    if (!payload) {
      throw new UnauthorizedException(
        '認証情報が無効です。再度ログインしてください。',
      );
    }

    // テナント状態チェック（MANAGER / CLIENT のみ）
    await this.ensureTenantActive(payload);

    return payload;
  }

    private async ensureTenantActive(payload: AuthPayload): Promise<void> {
    // 開発者はテナント状態に関係なく通す
    if (payload.role === 'DEVELOPER') {
      return;
    }

    // tenantId が無いのはそもそもおかしい
    if (payload.tenantId == null) {
      throw new UnauthorizedException(
        'テナント情報が不正です。管理者にお問い合わせください。',
      );
    }

    // DB からテナントを取得
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: payload.tenantId },
    });

    if (!tenant) {
      throw new UnauthorizedException(
        'テナント情報が見つかりません。管理者にお問い合わせください。',
      );
    }

    // 有効フラグ
    if (!tenant.isActive) {
      throw new UnauthorizedException(
        'テナントが無効になっています。管理者にお問い合わせください。',
      );
    }

    // 有効期限（validUntil が設定されている場合のみチェック）
    if (tenant.validUntil) {
      const now = new Date();
      if (tenant.validUntil.getTime() < now.getTime()) {
        throw new UnauthorizedException(
          'テナントの有効期限が切れています。管理者にお問い合わせください。',
        );
      }
    }

    // すべてOKなら、これまで通りの payload を返す
    //
  }

    // ★ 追加：同時ログイン数の上限チェック
  private async ensureSessionLimit(payload: AuthPayload): Promise<void> {
    // 開発者は同時ログイン制限なし
    if (payload.role === UserRole.DEVELOPER) {
      return;
    }

    // テナントプラン取得（MANAGER / CLIENT 用）
    let tenantPlan: string | null = null;
    if (payload.tenantId != null) {
      const tenant = await this.prisma.tenant.findUnique({
        where: { id: payload.tenantId },
        select: { plan: true },
      });
      tenantPlan = tenant?.plan ?? null;
    }

    const maxSessions = this.getMaxSessionsForUser(payload.role, tenantPlan);

    // 現在有効なセッション数をカウント
    const now = new Date();
    const activeCount = await this.prisma.userSession.count({
      where: {
        userId: payload.id,
        revokedAt: null,
        expiresAt: { gt: now },
      },
    });

    if (activeCount >= maxSessions) {
      throw new UnauthorizedException(
        '同じアカウントでの同時ログイン上限を超えています。他の端末からログアウトしてから再度お試しください。',
      );
    }
  }

  // ★ 追加：ログイン成功時にセッションを1行作成
  private async createSession(payload: AuthPayload): Promise<void> {
    const now = new Date();
    // トークン有効期限 7日想定に合わせて、セッションの有効期限も7日後にしておく
    const expiresAt = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

    await this.prisma.userSession.create({
      data: {
        userId: payload.id,
        createdAt: now,
        expiresAt,
        revokedAt: null,
      },
    });
  }

    /**
   * 自分自身のパスワード変更
   * - 現在のパスワードをチェック
   * - 新パスワードと確認用の一致チェック
   */
  async changeOwnPassword(params: {
    userId: number;
    currentPassword: string;
    newPassword: string;
    confirmNewPassword: string;
  }): Promise<void> {
    const { userId, currentPassword, newPassword, confirmNewPassword } = params;

    // 1) ユーザーを取得
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      throw new BadRequestException('ユーザーが見つかりません。');
    }

    // ▼ ここ IMPORTANT ▼
    // パスワードを保存しているカラム名が schema.prisma に合わせている必要あり
    // 例: user.passwordHash / user.hashedPassword / user.password など
    // 下の "user.passwordHash" の部分は、実際のカラム名に合わせて変えてね。
    const password = (user as any).password;

    // 2) 現在のパスワードチェック
    const isMatch = await bcrypt.compare(currentPassword, password);
    if (!isMatch) {
      throw new BadRequestException('現在のパスワードが正しくありません。');
    }

    // 3) 新しいパスワードの一致チェック
    if (newPassword !== confirmNewPassword) {
      throw new BadRequestException(
        '新しいパスワードと確認用パスワードが一致しません。',
      );
    }

    // 4) 新しいパスワードをハッシュ化して保存
    const newHash = await bcrypt.hash(newPassword, 10);

    await this.prisma.user.update({
      where: { id: userId },
      data: {
        // ここもカラム名を schema.prisma に合わせて変更
        password: newHash,
      },
    });
  }

    /**
   * MANAGER が CLIENT のパスワードを強制変更する
   * - manager.role が MANAGER 以外なら Forbidden
   * - manager.tenantId 配下の CLIENT 以外は対象外
   */
  async managerResetClientPassword(
    manager: { id: number; role: UserRole | string; tenantId: number | null },
    params: {
      clientUserId: number;
      newPassword: string;
      confirmNewPassword: string;
    },
  ): Promise<void> {
    const { clientUserId, newPassword, confirmNewPassword } = params;

    // MANAGER 以外は使えないようにする（DEVELOPER や CLIENT からは呼ばせない）
    const roleValue =
      typeof manager.role === 'string' ? manager.role : UserRole[manager.role];

    if (roleValue !== 'MANAGER') {
      throw new ForbiddenException('MANAGER のみが利用できる操作です。');
    }

    if (!manager.tenantId) {
      throw new ForbiddenException('テナント情報がありません。');
    }

    if (newPassword !== confirmNewPassword) {
      throw new BadRequestException(
        '新しいパスワードと確認用パスワードが一致しません。',
      );
    }

    // 対象 CLIENT ユーザーを特定
    const clientUser = await this.prisma.user.findFirst({
      where: {
        id: clientUserId,
        tenantId: manager.tenantId,
        role: UserRole.CLIENT,
      },
    });

    if (!clientUser) {
      throw new BadRequestException(
        '指定された CLIENT ユーザーが見つかりません。',
      );
    }

    // パスワードをハッシュ化して上書き
    const newHash = await bcrypt.hash(newPassword, 10);

    await this.prisma.user.update({
      where: { id: clientUser.id },
      data: {
        // ⚠️ ここも実際のカラム名に合わせて変更してね
        // 例: passwordHash / hashedPassword / password など
        password: newHash,
      },
    });
  }


}
