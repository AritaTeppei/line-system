// backend/src/bookings/bookings.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import type { AuthPayload } from '../auth/auth.service';
import { LineService } from '../line/line.service'; // ★ 追加

// Prisma 側の enum BookingStatus と文字列だけ合わせたローカル定義
export enum BookingStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  CANCELED = 'CANCELED',
}

@Injectable()
export class BookingsService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly lineService: LineService,
  ) {}

  /**
   * ログインユーザーからテナントIDを決定
   */
  private ensureTenant(user: AuthPayload): number {
    if (!user.tenantId) {
      throw new Error('テナントが特定できません');
    }
    return user.tenantId;
  }

  /**
   * 自テナントの予約一覧（最新順）
   */
  async listBookings(user: AuthPayload) {
    const tenantId = this.ensureTenant(user);

    // PrismaService の型が古くて booking を知らないので any キャストで逃がす
    const prisma = this.prisma as any;

    return prisma.booking.findMany({
      where: { tenantId },
      orderBy: { bookingDate: 'desc' },
      include: {
        customer: true,
        car: true,
      },
    });
  }

  /**
   * 管理画面から新規予約を作成（PENDING）
   */
  async createBooking(
    user: AuthPayload,
    params: {
      customerId: number;
      carId: number;
      bookingDate: Date;
      timeSlot?: string;
      note?: string;
    },
  ) {
    const tenantId = this.ensureTenant(user);
    const prisma = this.prisma as any;

    // 念のため、顧客と車両が自テナントのものかチェック
    const customer = await prisma.customer.findFirst({
      where: { id: params.customerId, tenantId },
    });
    if (!customer) {
      throw new Error('指定された顧客が見つからないか、他テナントのデータです');
    }

    const car = await prisma.car.findFirst({
      where: { id: params.carId, tenantId },
    });
    if (!car) {
      throw new Error('指定された車両が見つからないか、他テナントのデータです');
    }

    return prisma.booking.create({
      data: {
        tenantId,
        customerId: customer.id,
        carId: car.id,
        bookingDate: params.bookingDate,
        timeSlot: params.timeSlot,
        note: params.note,
        status: BookingStatus.PENDING, // ← ここはローカル enum
        source: 'ADMIN',
      },
    });
  }

  /**
   * 予約ステータスの変更（CONFIRMED / CANCELED など）
   */
  async updateStatus(
    user: AuthPayload,
    bookingId: number,
    status: BookingStatus,
  ) {
    // まず対象予約を取得（テナントチェック込み）
    const booking = await this.prisma.booking.findUnique({
      where: { id: bookingId },
      include: {
        customer: true,
        car: true,
      },
    });

    if (!booking) {
      throw new Error('予約が見つかりません。');
    }

    // DEVELOPER 以外は自分のテナント以外を触れないようにする
    if (user.role !== 'DEVELOPER' && booking.tenantId !== user.tenantId) {
      throw new Error('他テナントの予約は操作できません。');
    }

    // ステータスを更新
    const updated = await this.prisma.booking.update({
      where: { id: bookingId },
      data: { status },
      include: {
        customer: true,
        car: true,
      },
    });

    // ステータスが「確定」になったときだけ LINE 通知
    if (status === BookingStatus.CONFIRMED) {
      const lineUid = updated.customer.lineUid;

      if (lineUid) {
        const customerName = `${updated.customer.lastName} ${updated.customer.firstName}`;

        const dateStr = updated.bookingDate
          ? updated.bookingDate.toISOString().slice(0, 10).replace(/-/g, '/')
          : '';

        const carName = updated.car?.carName ?? '';
        const plate = updated.car?.registrationNumber ?? '';

        const carLine =
          carName && plate
            ? `対象のお車：${carName}（${plate}）`
            : carName
            ? `対象のお車：${carName}`
            : '';

        const timeLine = updated.timeSlot
          ? `ご希望時間帯：${updated.timeSlot}`
          : '';

        const messageLines = [
          `${customerName} 様`,
          '',
          'このたびはご予約ありがとうございます。',
          '以下の内容でご予約を承りました。',
          '',
          dateStr ? `ご予約日：${dateStr}` : '',
          timeLine,
          carLine,
          '',
          '内容に変更がある場合は、お手数ですが店舗までご連絡ください。',
        ].filter(Boolean);

        try {
          await this.lineService.sendText(lineUid, messageLines.join('\n'));
        } catch (e: any) {
          // ここでエラーにしてもいいけど、とりあえずサーバーは落とさないようにしておく
          console.error(
            `updateStatus: LINE 予約確定メッセージ送信失敗 bookingId=${bookingId}, error=${
              e?.message ?? e
            }`,
          );
        }
      }
    }

    return updated;
  }
}
